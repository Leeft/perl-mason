
=head1 NAME

Mason::Manual::Tutorial - Mason tutorial

=head1 DESCRIPTION

This tutorial shows how to build a sample web application - a wiki called Mwiki
- using Mason and PSGI.

A real web application would almost certainly employ a real data layer (DBI,
DBIx::Class, Rose::DB::Object) and possibly a separate web framework (Catalyst,
Dancer, Jifty) but for the sake of this tutorial we're going to do without
them.

=head1 REQUIREMENTS

In addition to Mason, you'll need. If you're using cpanm:

    cpanm CHI

=head1 DATA LAYER

For the sake of this tutorial we'll assume a single model class,
C<Mwiki::Node>, with the following API:

    # Class methods
    all() - returns a list of Mwiki::Page objects representing all pages in the wiki
    find($title) - returns the Mwiki::Page object with the specified title, or undef
    
    # Instance methods
    title() - title of the page
    content() - content of the page, in Markdown format
    content_as_html() - content of the page, in HTML format
    update(hashref) - update fields with values from hashref

=head1 Chapter 1

=head2 Top-level page components, index files

Here's our home page component, C</index.m>:

    <html>
      <head>
        <link rel="stylesheet" href="/static/css/mwiki.css">
        <title>Mwiki: Home</title>
      </head>
      <body>
  
        <h3>Welcome to Mwiki.</h3>
        
        <form action="/create">
        Create a node: 
        <input type=text name=title>
        <input type=submit>
        </form>
        
        <p>List of current nodes:</p>
        
        <& all_nodes.mi &>
        
      </body>
    </html>

In general, any component with a C<.m> extension is considered a I<top-level>
component, that is, it can be reached by an external URL.

index.m is a special path - it will match the URI of its directory, in this
case '/'.

We have a create node form that submits to /create, and a list of current
nodes.

Most of this component contains just HTML, which will be output exactly as
written.  The single piece of special Mason syntax here is

    <& all_nodes.mi &>

This is a I<component call> - it calls another component, whose output is
inserted in place.

Splitting a page into multiple components has much the same benefits as
splitting a regular program into multiple subroutines or objects:
encapsulation, reuse, etc.

=head1 Chapter 2

=head2 Internal components, %-lines, substitution tags, <%init> blocks

Because all_nodes.mi has an ".mi" extension (rather than ".m"), it is an
I<internal> rather than a top-level component, and cannot be reached by an
external URL. It can only be reached via a component call from another
component.

    <ul class="node_list">
    % foreach my $node (@nodes) {
      <li>
        <a href="/node/view?title=<% $node->title %>"><% $node->title %></a>
      </li>
    % }
    </ul>
    
    <%init>
    my @nodes = sort { $a->title cmp $b->title } Mwiki::Node->all();
    </%init>

Three new pieces of syntax here:

=over

=item Init block

The C<< <%init> >> block at the bottom specifies a block of Perl code to run
when this component is first called. In this case it fetches and sorts the list
of wiki nodes into a lexical variable C<< @nodes >>.

=item %-lines

The lines

    % foreach my $node (@nodes) {
    % }

begin with a single '%', and thus are treated as Perl rather than output
(HTML). %-lines are a good way to wrap for-loops, while-loops, and
if-statements around portions of the component.

=item Substitution tags

The line

    <a href="/node/view?title=<% $node->title %>"><% $node->title %></a>

shows two substitution tags. The code within C<< <% >> and C<< %> >> is treated
as a Perl expression, and the result of the expression is output in place.

=back

The final output of this component will look like:

  <ul class="node_list">
    <li>
      <a href="/node/view?title=Baseball">Baseball</a>
    </li>
    <li>
      <a href="/node/view?title=Football">Football</a>
    </li>
    ...
  </ul>

=head1 Chapter 3

=head2 Attributes, dollar-dot notation, passing arguments to components

Now it's time to create the C</node/view.m> component:

    <%args>
    $.title
    </%args>

    <html>
      <head>
        <link rel="stylesheet" href="/static/css/mwiki.css">
        <title>Mwiki: <% $.title %></title>
      </head>
      <body>

        <& nav_links.mi, title => $title &>
        <hr>
        <% $node->content_as_html() %>
        </hr>
        <& nav_links.mi, title => $title &>
        
      </body>
    </html>

    <%init>
    my $node = MyWiki::Node->find($.title)
        or $m->not_found;
    </%init>

In lines 1-3 we declare an incoming attribute, 'title'. These lines are
equivalent to the Moose syntax

    has 'title' => ();

Attributes in a top-level page component take on the values passed in the URL
query string. e.g. for the URL

    /node/view?title=Baseball

title will be set to 'Baseball'.

Throughout the component, we refer to the title attribute via the expression

    $.title

This not-quite-valid-Perl syntax is translated behind the scenes to

    $self->title

and is one of the rare cases in Mason where we use source filtering to create
new syntax within Perl code - because we want attributes and method calls to be
as convenient as possible.  The filter itself is performed by the L<DollarDot
plugin|Mason::Plugin::DollarDot>, which is in the default plugins list but can
be omitted if the syntax offends you. :)

On line __, we try to find a node with the specified title. If unsuccessful, we
call C<< $m->not_found() >>.  This clears anything that might be in the output
buffer and aborts the request with a 404 HTTP status. This is a convenience
method provided by the L<PSGIHandler plugin|Mason::Plugin::PSGIHandler> and
there is a similar method for L<Mason::Plugin::PSGIHandler/redirect>.

On lines __ and __ we call internal component C<< nav_links.mi >>, so as to
give us an identical set of links on the top and bottom of the node content.
This time we're passing a name/value argument pair. Note that because this is a
relative link, Mason will look for the component in the current directory (C<<
/node >>).

Here's /node/nav_links.mi:

    <%args>
    $.title => (required => 1);
    </%args>

    <a href="/node/edit/<% $.title %>">Edit</a> |
    <a href="/node/delete/<% $.title %>">Delete</a>

Again we have a declaration of attribute C<< title >>, but this time its value
is coming from the component call. We specify that the attribute is required;
an error will be thrown if it is omitted.

=head1 Chapter 5

=head2 Templates / content wrapping, autobases, inheritance, method modifiers

C</index.m> and C</node/view.m> have the same outer HTML template, and other
pages will as well.  It's going to be tedious to repeat this everywhere. And of
course, we don't have to. We take the common pieces out of the C</index.m> and
C</node/view.m> and place them into a new component called Base.m:

    <%augment wrap>
      <html>
        <head>
          <link rel="stylesheet" href="/static/css/mwiki.css">
          <title>Mwiki</title>
        </head>
        <body>
          <% inner() %>
        </body>
      </html>
    </%augment>

When any page in our hierarchy is rendered, Base.m will get control first. It
will render the upper portion of the template (lines 2-6), then call the
specific page component, then render the lower portion of the template (lines
8-9).

How does this magic work?

=over

=item 1.

Any component named Base.m is an I<autobase> component. It automatically
becomes the superclass of any component in its directory and below. Thus,
C</index.m> and C</node/view.m> both automatically inherit from Base.m.

=item 2.

When Mason dispatches to a page component like C</index.m> or C</node/view.m>,
it doesn't call its C<main> method directly. Instead, it calls this chain of
methods:

    handle -> render -> wrap -> main

By default each method in the chain just calls the next one, so the usual
behavior is to effectively call C<main>. However, in this case we are
augmenting the wrap method, which uses the Moose inner/augment call pattern. In
general, any superclass which augments the wrap method can output content
before and after its subclasses.

=back

C<< <%augment> >> is actually a generic block that can be used with any method,
though in practice is most often used with C<< wrap >>. There are analagous
blocks for each of Moose's L<method modifiers|Moose::Manual::MethodModifiers>:
C<< <%before> >>, C<< <%after> >>, C<< <%around> >> and C<< <%override> >>.

Now, we can remove those boilerplate lines from C</index.m> and
C</node/view.m>.

=head1 Chapter 6

=head2 RESTful URLs and routes

URLs like

    /node/view?title=Baseball

are somewhat old-school and not well optimized for search engines. It would be
cooler to use RESTful URLs:

    /node/view/Baseball

Let's modify C</node/view.m> to accept this kind of URL. To do this, we simply
replace

    <%args>
    $.title
    </%args>

with

    <%route /:title>

A I<route> specifies what to do with the remainder of the URL after /view. In
this case we expect a single path portion that contains the title. The C<<
<%route> >> tag is one of several ways of defining routes provided by the
L<Routes plugin|Mason::Plugin::Routes>.

Any matches from the route (in this case C<title>) are passed to the
component's constructor as attributes. And, a simple C<title> attribute is
automatically declared if we don't create one explicitly.

=head1 Chapter 7

=head2 Form handling

Here's C</node/edit.m>:

    <%init>
    my $node = MyWiki::Node->find($.title)
        or $m->not_found;
    </%init>
