THE FIRST TOP-LEVEL COMPONENT: /index.m

Here's our home page component, /index.m:

    <html>
      <head>
        <link rel="stylesheet" href="/static/css/mwiki.css">
        <title>MWiki: Home</title>
      </head>
      <body>
  
        <h3>Welcome to MWiki.</h3>
        
        <form action="/create">
        Create a node: 
        <input type=text name=title>
        <input type=submit>
        </form>
        
        <p>List of current nodes:</p>
        
        <& all_nodes.mi &>
        
      </body>
    </html>

In general, any component with a ".m" extension is considered a I<top-level> component,
that is, it can be reached by an external URL.

index.m is a special path - it will match the URI of its directory, in this case '/'.

We have a create node form that submits to /create, and a list of current nodes.

Most of this component contains just HTML, which will be output exactly as written.  The
single piece of special Mason syntax here is

    <& all_nodes.mi &>

This is a I<component call> - it calls another component, whose output is inserted in place.

Splitting a page into multiple components has much the same benefits as splitting a
regular program into multiple subroutines or objects: encapsulation, reuse, etc.

THE FIRST INTERNAL COMPONENT: all_nodes.mi

Because all_nodes.mi has an ".mi" extension (rather than ".m"), it is an I<internal> rather
than a top-level component, and cannot be reached by an external URL. It can only be
reached via a component call from another component.

    <ul class="node_list">
    % foreach my $node (@nodes) {
      <li>
        <a href="/node/view/<% $node->title %>"><% $node->title %></a>
      </li>
    % }
    </ul>
    
    <%init>
    my @nodes = sort { $a->title cmp $b->title } MWiki::Node->all();
    </%init>

Three new pieces of syntax here:

=over

=item Init block

The C<< <%init> >> block at the bottom specifies a block of Perl code
to run when this component is first called. In this case it fetches and
sorts the list of wiki nodes into a lexical variable C<< @nodes >>.

=item %-lines

The lines

    % foreach my $node (@nodes) {
    % }

begin with a single '%', and thus are treated as Perl rather than output (HTML).
%-lines are a good way to wrap for-loops, while-loops, and if-statements
around portions of the component.

=item Substitution tags

The line

    <a href="/node/view/<% $node->title %>"><% $node->title %></a>

shows two substitution tags. The code within C<< <% >> and C<< %> >> is treated as a Perl
expression, and the result of the expression is output in place.

=back

The final output of this component will look like:

  <ul class="node_list">
    <li>
      <a href="/node/view/Baseball">Baseball</a>
    </li>
    <li>
      <a href="/node/view/Football">Football</a>
    </li>
    ...
  </ul>

Now it's time to create the /node/view page.

THE SECOND TOP-LEVEL COMPONENT: /node/view.m

    <%args>
    $.title
    </%args>

    <html>
      <head>
        <link rel="stylesheet" href="/static/css/mwiki.css">
        <title>MWiki: <% $.title %></title>
      </head>
      <body>

        <& nav_links.mi, title => $title %>
        <hr>
        <% $node->content_as_html() %>
        </hr>
        <% nav_links.mi, title => $title %>
        
      </body>
    </html>

    <%init>
    my $node = MyWiki::Node->find($.title)
        or $m->not_found;
    </%init>

In lines 1-3 we declare an incoming attribute, 'title'. These lines are equivalent to the
Moose syntax

    has 'title' => ();

Attributes in a top-level page component take on the values passed in the URL query
string. e.g. for the URL

    /node/view?title=Baseball

title will be set to 'Baseball'.

Throughout the component, we refer to the title attribute via the expression

    $.title

This not-quite-valid-Perl syntax is translated behind the scenes to

    $self->title

and is one of the rare cases in Mason where we use source filtering to create new syntax
within Perl code - because we want attributes and method calls to be as convenient as
possible.  The filter itself is performed by the L<DollarDot
plugin|Mason::Plugin::DollarDot>, which is in the default plugins list but can be omitted
if the syntax offends you. :)

On line __, we try to find a node with the specified title. If unsuccessful, we call C<<
$m->not_found() >>.  This clears anything that might be in the output buffer and aborts
the request with a 404 HTTP status. This is a convenience method provided by the
L<PSGIHandler plugin|Mason::Plugin::PSGIHandler> and there is a similar method for
L<Mason::Plugin::PSGIHandler/redirect>.

On lines __ and __ we call internal component C<< nav_links.mi >>, so as to give us an
identical set of links on the top and bottom of the node content. This time we're passing
a name/value argument pair. Note that because this is a relative link, Mason will look
for the component in the current directory (C<< /node >>).

PASSING ATTRIBUTES TO COMPONENTS

Here's /node/nav_links.mi:

    <%args>
    $.title => (required => 1);
    </%args>

    <a href="/edit/<% $.title %>">Edit</a> |
    <a href="/delete/<% $.title %>">Delete</a>

Again we have a declaration of attribute C<< title >>, but this time its value is coming
from the component call. We specify that the attribute is required; an error will be thrown
if it is omitted.

TEMPLATE WRAPPERS

index.m and /node/view.m have the same outer HTML template, and other pages will as well.  It's
going to be tedious to repeat this everywhere. And of course, we don't have to. We take
the common pieces out of the index.m and /node/view.m and place them into a new component called
Base.m:

    <%augment wrap>
      <html>
        <head>
          <link rel="stylesheet" href="/static/css/mwiki.css">
          <title>Mwiki</title>
        </head>
        <body>
          <% inner() %>
        </body>
      </html>
    </%augment>

When any page in our hierarchy is rendered, Base.m will get control first. It will render
the upper portion of the template (lines 2-6), then call the specific page component,
then render the lower portion of the template (lines 8-9).

How does this magic work?

=over

=item 1.

Any component named Base.m is an I<autobase> component. It automatically becomes the
superclass of any component in its directory and below. Thus, index.m and /node/view.m
both automatically inherit from Base.m.

=item 2.

When Mason dispatches to a page component like index.m or /node/view.m, it doesn't call
its C<main> method directly. Instead, it calls this chain of methods:

    handle -> render -> wrap -> main

By default each method in the chain just calls the next one, so the usual behavior is to
effectively call C<main>. However, in this case we are augmenting the wrap method, which
uses the Moose inner/augment call pattern. In general, any superclass which augments
the wrap method can output content before and after its subclasses.

=back

C<< <%augment> >> is actually a generic block that can be used with any method, though in
practice is most often used with C<< wrap >>. There are analagous blocks for each of Moose's
L<method modifiers|Moose::Manual::MethodModifiers>: C<< <%before> >>, C<< <%after> >>,
C<< <%around> >> and C<< <%override> >>.

Now, we can remove those boilerplate lines from index.m and /node/view.m.

REST-STYLE URLS AND ROUTES

URLs like

    /node/view?title=Baseball

are somewhat old-school and not well optimized for search engines. It would be cooler
to use RESTful URLs:

    /node/view/Baseball

Let's modify /node/view.m to accept this kind of URL. To do this, we simply replace

    <%args>
    $.title
    </%args>

with

    <%route /:title>

A I<route> specifies what to do with the remainder of the URL after /view. In this case we
expect a single path portion that contains the title. The C<< <%route> >> tag is one of
several ways of defining routes provided by the L<Routes plugin|Mason::Plugin::Routes>.

Any matches from the route (in this case 'title') are passed to the component's
constructor as attributes. And, a C<< title >> attribute is automatically created if
you don't create one explicitly.

The rest of the component can remain the same.
